# Manage Sandbox Environment with Test Kitchen

Running Chef on our local workstation, like we did in the previous chapter, is not the best approach. There are at least two reasons why it is not the best approach. First, because our local workstation does not match our production environment. The second is even if our local workstation matches the production environment, we don't really want to take the risk of running untested Chef code locally.

Therefore, we will create a sandbox environment using Test Kitchen and Vagrant. The book actually provides guidance to use Vagrant and VirtualBox, but I only use Vagrant for the time being.

## Steps

To create a sandbox environment using Test Kitchen and Vagrant, first we need Vagrant installed. For this learning not, I won't provide detailed steps to install Vagrant. Maybe later I will create a separate note on installing Vagrant.

Afterward, we will setup Test Kitchen with the following steps:

1. `mkdir kitchen`
2. `cd kitchen`
3. `kitchen init --create-gemfile`
4. Edit `Gemfile` generated by `kitchen init --create-gemfile`, add this line: `gem kitchen-vagrant`
5. `bundle install`
6. Edit `kitchen.yml` to look like this:

```
---
driver:
  name: vagrant

provisioner:
  name: chef_solo

platforms:
  - name: centos65
    driver:
      box: learningchef/centos65
      box_url: learningchef/centos65

suites:
  - name: default
    run_list:
    attributes:
```

7. `kitchen create default-centos65`
8. To verify that all the steps are performed correctly, run `kitchen list`. The result should look like this:

```
Instance          Driver   Provisioner  Verifier  Transport  Last Action  Last Error
default-centos65  Vagrant  ChefSolo     Busser    Ssh        Created      <None>
```

## YAML Overview

Now that we have created our Test Kitchen configuration, we will discuss a litlle bit about `kitchen.yml` file that we use to configure it. The file is written in YAML file format. YAML files work with two kinds of data: key-value pairs and list.

This is an example of a key-value pair:

```
name: vagrant
``` 

Key-value pairs can be nested so that a value of a key is antoher key-value pair. To create nested key-value pairs, we just need to add an indent from the parent with at least one space. To keep compatibility with Ruby's convention, I will just use two spaces to indent a nested key-value pair. One important thing is we can't use tab to create a nested key-value pair. Below is an example of a nested key-value pair:

```
driver:
  name: vagrant
```

Alternatively, we can use JSON format to define a nested key-value pair such as this one:

```
driver: { name: vagrant }
```

Lists are the other kind of data in a YAML file. Lists contain ordered data. We can put a key-value pair inside a list, and we can put a list inside a key-value pair. For instance:

```
platforms:
  - name: centos65
  - name: ubuntu-16.04
```

## Inside 'kitchen.yml' File

A `kitchen.yml` file contains four main section:

1. `driver`  
   Specifies the driver plugin to use, plus configuration parameters to manage Test Kitchen environments. To see the list of drivers, use `kitchen driver discover` (at the time of this writing, I can't get `kitchen driver discover` command to work though). In our `kitchen.yml`, we use `kitchen-vagrant` driver. We can omit `kitchen-` part of the driver name when it is specified in `kitchen.yml` file.
2. `provisioner`  
   Determines which configuration management tool we use to provision the driver's environments. In our case, we used `chef_solo`.
3. `platforms`  
   A list of operating systems for which Test Kitchen will create instances.
4. `suites`  
   Specifies a configuration to run on each instance. Among other things, a suite contains a list of recipes to run on each instance.